#!/usr/bin/env python3
"""
Script direto para verificar automa√ß√£o espec√≠fica
"""

import asyncio
from supabase import create_async_client

# Configura√ß√µes de produ√ß√£o
SUPABASE_URL = "https://siangdfgebkbmmkwjjob.supabase.co"
SUPABASE_SERVICE_ROLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNpYW5nZGZnZWJrYm1ta3dqam9iIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MzQ2NTIxOCwiZXhwIjoyMDY5MDQxMjE4fQ.3lGCX8yBR_KeoVzLK2K-2Z-wNjKkNkFxZbftCX9sJms"

AUTOMATION_ID = "7163752f-d41e-472a-9fe9-e38b102012bb"
THREAD_ID = "ab5b1cd6-cc07-4327-af29-c6cd0fae77ca"  # Thread usada no teste
DEBUG_AGENT_RUN_ID = "c75ef691-80d4-4a9e-87da-2df937efe9db"

async def check_automation():
    try:
        print("üîç Conectando ao Supabase...")
        client = await create_async_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)
        
        # 1. Buscar automa√ß√£o diretamente pelo ID
        print(f"üéØ Buscando automa√ß√£o: {AUTOMATION_ID}")
        
        # Primeiro tentar na tabela 'agent_triggers'
        trigger_result = await client.table('agent_triggers').select('*').eq('trigger_id', AUTOMATION_ID).execute()
        
        found_trigger = None
        if trigger_result.data:
            trigger = trigger_result.data[0]
            found_trigger = trigger
            status_emoji = "üü¢" if trigger.get('is_active') else "üî¥"
            
            print(f"\n{status_emoji} AUTOMA√á√ÉO ENCONTRADA:")
            print(f"   ID: {trigger['trigger_id']}")
            print(f"   Nome: {trigger.get('name', 'Sem nome')}")
            print(f"   Status: {'ATIVO' if trigger.get('is_active') else 'INATIVO'}")
            print(f"   Tipo: {trigger.get('trigger_type', 'N/A')}")
            print(f"   Agent ID: {trigger.get('agent_id', 'N/A')}")
            print(f"   Criado: {trigger.get('created_at', 'N/A')}")
            
            if trigger.get('description'):
                print(f"   Descri√ß√£o: {trigger['description']}")
                
            if trigger.get('config'):
                print(f"   Config: {trigger['config']}")
                
                # Analisar configura√ß√£o espec√≠fica para email
                config = trigger.get('config', {})
                workflow_id = config.get('workflow_id')
                if workflow_id:
                    print(f"\nüîç WORKFLOW CONECTADO: {workflow_id}")
                    print(f"   Este √© o workflow que define as a√ß√µes da automa√ß√£o")
                    
                    # Buscar detalhes do workflow
                    try:
                        workflow_result = await client.table('agent_workflows').select('*').eq('workflow_id', workflow_id).execute()
                        if workflow_result.data:
                            workflow = workflow_result.data[0]
                            print(f"\nüìã DETALHES DO WORKFLOW:")
                            print(f"   ID: {workflow.get('workflow_id')}")
                            print(f"   Nome: {workflow.get('name', 'Sem nome')}")
                            print(f"   Thread ID: {workflow.get('thread_id')}")
                            print(f"   Agent ID: {workflow.get('agent_id')}")
                            print(f"   Ativo: {workflow.get('is_active', 'N/A')}")
                            
                            if workflow.get('workflow_data'):
                                workflow_data = workflow.get('workflow_data')
                                print(f"   Dados do Workflow: {workflow_data}")
                                
                                # Verificar se h√° configura√ß√µes de email
                                if isinstance(workflow_data, dict):
                                    if 'email' in str(workflow_data).lower() or 'pipedream' in str(workflow_data).lower():
                                        print(f"   üîç POSS√çVEL CONFIGURA√á√ÉO DE EMAIL DETECTADA!")
                            
                        else:
                            print(f"   ‚ùå Workflow {workflow_id} n√£o encontrado na tabela agent_workflows")
                    except Exception as workflow_error:
                        print(f"   ‚ö†Ô∏è  Erro ao buscar workflow: {workflow_error}")
        else:
            print("‚ùå Automa√ß√£o espec√≠fica n√£o encontrada")
            
            # Buscar qualquer automa√ß√£o existente
            print("üîç Buscando automa√ß√µes existentes...")
            try:
                any_triggers = await client.table('agent_triggers').select('*').limit(3).execute()
                if any_triggers.data:
                    print(f"‚úÖ Encontradas {len(any_triggers.data)} automa√ß√µes na base:")
                    for trigger in any_triggers.data:
                        status_emoji = "üü¢" if trigger.get('is_active') else "üî¥"
                        print(f"  {status_emoji} {trigger['trigger_id'][:8]}... - {trigger.get('name', 'Sem nome')}")
                    # Usar a primeira automa√ß√£o encontrada
                    found_trigger = any_triggers.data[0]
                else:
                    print("‚ùå Nenhuma automa√ß√£o encontrada na base")
            except Exception as e:
                print(f"‚ùå Erro ao buscar automa√ß√µes: {e}")
        
        # 2. Buscar execu√ß√µes relacionadas da automa√ß√£o espec√≠fica
        automation_thread_id = None
        if found_trigger and found_trigger.get('trigger_id') == AUTOMATION_ID:
            # Se encontramos a automa√ß√£o, podemos tentar deduzir o thread_id dela
            # Baseado na estrutura, vamos buscar por qualquer execu√ß√£o com esta automa√ß√£o
            print(f"\n‚ö° Buscando execu√ß√µes da automa√ß√£o {AUTOMATION_ID}...")
            
            # Tentar buscar por workflow_triggers que conecta automa√ß√£o com threads
            try:
                workflow_result = await client.table('agent_workflows').select('thread_id').eq('trigger_id', AUTOMATION_ID).execute()
                if workflow_result.data:
                    automation_thread_id = workflow_result.data[0]['thread_id']
                    print(f"üìã Thread ID da automa√ß√£o encontrado: {automation_thread_id}")
                else:
                    print("üîç Nenhum workflow encontrado para esta automa√ß√£o")
            except Exception as workflow_error:
                print(f"‚ö†Ô∏è  Erro ao buscar workflow: {workflow_error}")
        
        # Buscar execu√ß√µes usando o thread_id da automa√ß√£o ou fallback para o teste
        target_thread_id = automation_thread_id or THREAD_ID
        print(f"\n‚ö° Buscando execu√ß√µes da thread {target_thread_id}...")
        runs_result = await client.table('agent_runs').select('*').eq('thread_id', target_thread_id).order('created_at', desc=True).limit(10).execute()
        
        if runs_result.data:
            print(f"‚úÖ √öltimas {len(runs_result.data)} execu√ß√µes:")
            
            for run in runs_result.data:
                status = run.get('status', 'unknown')
                status_emoji = {
                    'completed': '‚úÖ',
                    'running': 'üîÑ', 
                    'failed': '‚ùå',
                    'pending': '‚è≥',
                    'cancelled': 'üö´'
                }.get(status, '‚ùì')
                
                print(f"\n  {status_emoji} {run['id'][:8]}... ({status})")
                print(f"     Criado: {run.get('created_at', 'N/A')[:19]}")
                
                if run.get('completed_at'):
                    print(f"     Conclu√≠do: {run.get('completed_at', 'N/A')[:19]}")
                    
                if run.get('error'):
                    print(f"     Erro: {run['error'][:100]}...")
        else:
            print("‚ùå Nenhuma execu√ß√£o encontrada")
        
        # 3. Verificar mensagens recentes da thread
        print(f"\nüí¨ √öltimas mensagens da thread...")
        try:
            messages_result = await client.table('messages').select('type, content, created_at').eq('thread_id', THREAD_ID).order('created_at', desc=True).limit(3).execute()
            
            if messages_result.data:
                for msg in messages_result.data:
                    role_emoji = "üë§" if msg.get('type') == 'user' else "ü§ñ"
                    content = msg.get('content', '')
                    preview = content[:100] + "..." if len(content) > 100 else content
                    timestamp = msg.get('created_at', 'N/A')[:19] if msg.get('created_at') else 'N/A'
                    print(f"  {role_emoji} {timestamp}: {preview}")
            else:
                print("‚ùå Nenhuma mensagem encontrada")
        except Exception as msg_error:
            print(f"‚ö†Ô∏è  Erro ao buscar mensagens: {msg_error}")
        
        # 4. Buscar dados v√°lidos para teste (NEW)
        print(f"\nüîç BUSCANDO DADOS V√ÅLIDOS PARA TESTE...")
        
        # Buscar threads dispon√≠veis
        print("üìù Buscando threads dispon√≠veis...")
        threads_result = await client.table('threads').select('thread_id, account_id, project_id, created_at').order('created_at', desc=True).limit(10).execute()
        
        valid_combinations = []
        
        if threads_result.data:
            print(f"‚úÖ Encontradas {len(threads_result.data)} threads")
            
            for thread in threads_result.data:
                thread_id = thread['thread_id']
                project_id = thread['project_id']
                account_id = thread['account_id']
                
                # Verificar se tem project associado
                if project_id:
                    project_result = await client.table('projects').select('project_id, name, account_id').eq('project_id', project_id).execute()
                    
                    if project_result.data:
                        project = project_result.data[0]
                        
                        # Buscar agents para esta account
                        # Assumindo que existe uma tabela 'agents' baseada no schema agent_triggers
                        try:
                            agents_result = await client.table('agents').select('agent_id, name, account_id').eq('account_id', account_id).limit(3).execute()
                            
                            if agents_result.data:
                                for agent in agents_result.data:
                                    combination = {
                                        'thread_id': thread_id,
                                        'project_id': project_id,
                                        'agent_id': agent['agent_id'],
                                        'account_id': account_id,
                                        'project_name': project['name'],
                                        'agent_name': agent['name'],
                                        'thread_created': thread['created_at']
                                    }
                                    valid_combinations.append(combination)
                                    
                        except Exception as agent_error:
                            print(f"‚ö†Ô∏è  Erro ao buscar agents: {agent_error}")
                            # Tentar buscar agent_id da automa√ß√£o existente
                            if found_trigger:
                                trigger_agent_id = found_trigger.get('agent_id')
                                if trigger_agent_id:
                                    combination = {
                                        'thread_id': thread_id,
                                        'project_id': project_id,
                                        'agent_id': trigger_agent_id,
                                        'account_id': account_id,
                                        'project_name': project['name'],
                                        'agent_name': 'Agent da automa√ß√£o',
                                        'thread_created': thread['created_at']
                                    }
                                    valid_combinations.append(combination)
        
        # Exibir combina√ß√µes v√°lidas encontradas
        if valid_combinations:
            print(f"\nüéØ ENCONTRADAS {len(valid_combinations)} COMBINA√á√ïES V√ÅLIDAS:")
            for i, combo in enumerate(valid_combinations[:5], 1):  # Mostrar apenas 5
                print(f"\n  {i}. üìã COMBINA√á√ÉO {i}:")
                print(f"     Thread ID: {combo['thread_id']}")
                print(f"     Project ID: {combo['project_id']}")
                print(f"     Agent ID: {combo['agent_id']}")
                print(f"     Account ID: {combo['account_id']}")
                print(f"     Project: {combo['project_name']}")
                print(f"     Agent: {combo['agent_name']}")
                print(f"     Thread criada: {combo['thread_created'][:19]}")
                
            # Recomendar a melhor combina√ß√£o para teste
            best_combo = valid_combinations[0]
            print(f"\nüèÜ RECOMENDA√á√ÉO PARA TESTE:")
            print(f"   Thread ID: {best_combo['thread_id']}")
            print(f"   Project ID: {best_combo['project_id']}")  
            print(f"   Agent ID: {best_combo['agent_id']}")
            
            # Comando curl para testar
            import uuid
            test_agent_run_id = str(uuid.uuid4())
            
            print(f"\nüß™ COMANDO PARA TESTAR:")
            print(f"curl -X POST 'https://prophet-milo-f3hr5.ondigitalocean.app/api/internal/execute-agent' \\")
            print(f"  -H 'Content-Type: application/json' \\")
            print(f"  -H 'x-internal-secret: sk_trigger_7f9a8b6c5d4e3f2a1b0c9d8e7f6a5b4c3d2e1f0' \\")
            print(f"  -d '{{")
            print(f"    \"agent_run_id\": \"{test_agent_run_id}\",")
            print(f"    \"thread_id\": \"{best_combo['thread_id']}\",")
            print(f"    \"project_id\": \"{best_combo['project_id']}\",")
            print(f"    \"agent_config\": {{\"name\": \"Test Agent\", \"agent_id\": \"{best_combo['agent_id']}\"}},")
            print(f"    \"trigger_variables\": {{\"message\": \"Teste debugging erro boolean\"}}")
            print(f"  }}' -v")
            
            print(f"\nüîç AGENT RUN ID PARA DEBUG: {test_agent_run_id}")
            print(f"   Use este ID para verificar logs de debug ap√≥s execu√ß√£o")
            
        else:
            print("‚ùå Nenhuma combina√ß√£o v√°lida encontrada")
        
        # 5. Verificar nossa execu√ß√£o de teste espec√≠fica
        print(f"\nüß™ VERIFICANDO EXECU√á√ÉO DE TESTE {DEBUG_AGENT_RUN_ID}...")
        print(f"üîç VERIFICANDO NOVA EXECU√á√ÉO DE TESTE: 63a6732a-feb5-40d1-a75b-6e271294445b...")
        print(f"üî¨ VERIFICANDO EXECU√á√ÉO ATUAL DE DEBUG: 0cedd4c7-fc61-43d4-9a3b-d83761dff50a...")
        print(f"üî¨ VERIFICANDO SEGUNDA EXECU√á√ÉO DE DEBUG: test-boolean-debug-2...")
        
        try:
            test_run_result = await client.table('agent_runs').select('*').eq('id', DEBUG_AGENT_RUN_ID).execute()
            new_test_run_result = await client.table('agent_runs').select('*').eq('id', '63a6732a-feb5-40d1-a75b-6e271294445b').execute()
            current_test_run_result = await client.table('agent_runs').select('*').eq('id', '0cedd4c7-fc61-43d4-9a3b-d83761dff50a').execute()
            second_test_run_result = await client.table('agent_runs').select('*').eq('id', 'test-boolean-debug-2').execute()
            
            # Check old test run
            if test_run_result.data:
                test_run = test_run_result.data[0]
                status = test_run.get('status', 'unknown')
                status_emoji = {
                    'completed': '‚úÖ',
                    'running': 'üîÑ', 
                    'failed': '‚ùå',
                    'pending': '‚è≥',
                    'cancelled': 'üö´'
                }.get(status, '‚ùì')
                
                print(f"\n{status_emoji} EXECU√á√ÉO DE TESTE ANTIGA ENCONTRADA:")
                print(f"   ID: {test_run['id']}")
                print(f"   Status: {status}")
                print(f"   Thread ID: {test_run['thread_id']}")
                print(f"   Criado: {test_run.get('started_at', 'N/A')[:19]}")
                
                if test_run.get('completed_at'):
                    print(f"   Conclu√≠do: {test_run.get('completed_at', 'N/A')[:19]}")
                    
                if test_run.get('error'):
                    print(f"   üö® ERRO CAPTURADO: {test_run['error']}")
                    
                    # Se h√° erro, isso pode ser nosso erro boolean!
                    if 'bool' in test_run['error'].lower():
                        print("   üéØ ERRO BOOLEAN DETECTADO!")
                        print("   üìä Este √© exatamente o erro que est√°vamos procurando!")
            else:
                print("‚ùå Execu√ß√£o de teste antiga n√£o encontrada na base de dados")
                
            # Check new test run
            if new_test_run_result.data:
                new_test_run = new_test_run_result.data[0]
                status = new_test_run.get('status', 'unknown')
                status_emoji = {
                    'completed': '‚úÖ',
                    'running': 'üîÑ', 
                    'failed': '‚ùå',
                    'pending': '‚è≥',
                    'cancelled': 'üö´'
                }.get(status, '‚ùì')
                
                print(f"\n{status_emoji} NOVA EXECU√á√ÉO DE TESTE ENCONTRADA:")
                print(f"   ID: {new_test_run['id']}")
                print(f"   Status: {status}")
                print(f"   Thread ID: {new_test_run['thread_id']}")
                print(f"   Criado: {new_test_run.get('started_at', 'N/A')[:19]}")
                
                if new_test_run.get('completed_at'):
                    print(f"   Conclu√≠do: {new_test_run.get('completed_at', 'N/A')[:19]}")
                    
                if new_test_run.get('error'):
                    print(f"   üö® ERRO CAPTURADO: {new_test_run['error']}")
                    
                    # Se h√° erro, isso pode ser nosso erro boolean!
                    if 'bool' in new_test_run['error'].lower():
                        print("   üéØ ERRO BOOLEAN DETECTADO!")
                        print("   üìä Este √© exatamente o erro que est√°vamos procurando!")
                    elif 'Thread not found' in new_test_run['error']:
                        print("   üîç ERRO DE THREAD NOT FOUND DETECTADO!")
                        print("   üìä O sistema de debugging est√° funcionando - erro capturado antes da execu√ß√£o!")
            else:
                print("‚ùå Nova execu√ß√£o de teste n√£o encontrada na base de dados")
                print("‚ö†Ô∏è  Isso pode indicar que a execu√ß√£o falhou antes de ser registrada")
                
            # Check current test run  
            if current_test_run_result.data:
                current_test_run = current_test_run_result.data[0]
                status = current_test_run.get('status', 'unknown')
                status_emoji = {
                    'completed': '‚úÖ',
                    'running': 'üîÑ', 
                    'failed': '‚ùå',
                    'pending': '‚è≥',
                    'cancelled': 'üö´'
                }.get(status, '‚ùì')
                
                print(f"\n{status_emoji} EXECU√á√ÉO ATUAL DE DEBUG ENCONTRADA:")
                print(f"   ID: {current_test_run['id']}")
                print(f"   Status: {status}")
                print(f"   Thread ID: {current_test_run['thread_id']}")
                print(f"   Criado: {current_test_run.get('started_at', 'N/A')[:19]}")
                
                if current_test_run.get('completed_at'):
                    print(f"   Conclu√≠do: {current_test_run.get('completed_at', 'N/A')[:19]}")
                    
                if current_test_run.get('error'):
                    print(f"   üö® ERRO CAPTURADO: {current_test_run['error']}")
                    
                    # Se h√° erro, isso pode ser nosso erro boolean!
                    if 'bool' in current_test_run['error'].lower():
                        print("   üéØ ERRO BOOLEAN DETECTADO!")
                        print("   üìä Este √© exatamente o erro que est√°vamos procurando!")
                        print("   üîç Sistema de debugging funcionando perfeitamente!")
                else:
                    print("   ‚ÑπÔ∏è  Sem erros reportados - execu√ß√£o ainda em andamento ou bem-sucedida")
            else:
                print("‚ùå Execu√ß√£o atual de debug n√£o encontrada na base de dados")
                print("‚ö†Ô∏è  Pode indicar problema na cria√ß√£o do agent_run ou execu√ß√£o muito recente")
                
            # Check second test run  
            if second_test_run_result.data:
                second_test_run = second_test_run_result.data[0]
                status = second_test_run.get('status', 'unknown')
                status_emoji = {
                    'completed': '‚úÖ',
                    'running': 'üîÑ', 
                    'failed': '‚ùå',
                    'pending': '‚è≥',
                    'cancelled': 'üö´'
                }.get(status, '‚ùì')
                
                print(f"\n{status_emoji} SEGUNDA EXECU√á√ÉO DE DEBUG ENCONTRADA:")
                print(f"   ID: {second_test_run['id']}")
                print(f"   Status: {status}")
                print(f"   Thread ID: {second_test_run['thread_id']}")
                print(f"   Criado: {second_test_run.get('started_at', 'N/A')[:19]}")
                
                if second_test_run.get('completed_at'):
                    print(f"   Conclu√≠do: {second_test_run.get('completed_at', 'N/A')[:19]}")
                    
                if second_test_run.get('error'):
                    print(f"   üö® ERRO CAPTURADO: {second_test_run['error']}")
                    
                    # Se h√° erro, isso pode ser nosso erro boolean!
                    if 'bool' in second_test_run['error'].lower():
                        print("   üéØ ERRO BOOLEAN DETECTADO NA SEGUNDA EXECU√á√ÉO!")
                        print("   üìä Sistema de debugging capturou o erro com sucesso!")
                        print("   üîç Agora podemos analisar as condi√ß√µes que causam este erro!")
                else:
                    print("   ‚ÑπÔ∏è  Sem erros reportados - execu√ß√£o bem-sucedida")
            else:
                print("‚ùå Segunda execu√ß√£o de debug n√£o encontrada na base de dados")
                
        except Exception as test_error:
            print(f"‚ùå Erro ao verificar execu√ß√£o de teste: {test_error}")
        
        print("\n‚úÖ Verifica√ß√£o conclu√≠da!")
        
    except Exception as e:
        print(f"‚ùå Erro: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(check_automation())